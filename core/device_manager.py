#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Device Manager Module
T√≠ch h·ª£p logic device management t·ª´ core1.py
"""

import subprocess
import threading
import time
import traceback
import json
import os
from typing import List, Dict, Optional, Tuple
from PyQt6.QtCore import QObject, pyqtSignal, QThread
import uiautomator2 as u2
from utils.data_manager import data_manager

class Device:
    """Device class t√≠ch h·ª£p t·ª´ core1.py v·ªõi GUI support"""
    
    def __init__(self, device_id: str):
        self.device_id = device_id
        self.d = None
        self.connected = False
        self.screen_info = None
        self.device_info = None
        
    def connect(self) -> bool:
        """K·∫øt n·ªëi ƒë·∫øn device"""
        try:
            self.d = u2.connect(self.device_id)
            if self.d.info:
                self.connected = True
                self.device_info = self.d.info
                self.screen_info = {
                    'width': self.device_info.get('displayWidth', 1080),
                    'height': self.device_info.get('displayHeight', 2220)
                }
                return True
        except Exception as e:
            print(f"‚ùå L·ªói k·∫øt n·ªëi device {self.device_id}: {e}")
        return False
    
    def disconnect(self):
        """Ng·∫Øt k·∫øt n·ªëi device"""
        self.connected = False
        self.d = None
        self.screen_info = None
        self.device_info = None
    
    def is_connected(self) -> bool:
        """Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi"""
        return self.connected and self.d is not None
    
    def get_info(self) -> Dict:
        """L·∫•y th√¥ng tin device"""
        if self.device_info:
            return self.device_info
        return {}
    
    def get_screen_size(self) -> Tuple[int, int]:
        """L·∫•y k√≠ch th∆∞·ªõc m√†n h√¨nh"""
        if self.screen_info:
            return self.screen_info['width'], self.screen_info['height']
        return 1080, 2220
    
    def take_screenshot(self, save_path: str = None) -> str:
        """Ch·ª•p m√†n h√¨nh"""
        try:
            if not self.is_connected():
                return None
            
            if save_path is None:
                save_path = f"screenshot_{self.device_id.replace(':', '_')}_{int(time.time())}.png"
            
            self.d.screenshot(save_path)
            return save_path
        except Exception as e:
            print(f"‚ùå L·ªói ch·ª•p m√†n h√¨nh: {e}")
            return None
    
    # Basic touch operations
    def tap(self, x: int, y: int) -> bool:
        """Tap t·∫°i t·ªça ƒë·ªô x, y"""
        try:
            if self.is_connected():
                self.d.click(x, y)
                return True
        except Exception as e:
            print(f"‚ùå L·ªói tap: {e}")
        return False
    
    def swipe(self, start_x: int, start_y: int, end_x: int, end_y: int, duration: float = 0.5) -> bool:
        """Swipe t·ª´ ƒëi·ªÉm start ƒë·∫øn ƒëi·ªÉm end"""
        try:
            if self.is_connected():
                self.d.swipe(start_x, start_y, end_x, end_y, duration)
                return True
        except Exception as e:
            print(f"‚ùå L·ªói swipe: {e}")
        return False
    
    def input_text(self, text: str) -> bool:
        """Nh·∫≠p text"""
        try:
            if self.is_connected():
                self.d.send_keys(text)
                return True
        except Exception as e:
            print(f"‚ùå L·ªói input text: {e}")
        return False
    
    # Element operations
    def click_by_text(self, text: str, timeout: int = 5) -> bool:
        """Click element theo text"""
        try:
            if self.is_connected():
                element = self.d(text=text)
                if element.wait(timeout=timeout):
                    element.click()
                    return True
        except Exception as e:
            print(f"‚ùå L·ªói click by text: {e}")
        return False
    
    def click_by_resource_id(self, resource_id: str, timeout: int = 5) -> bool:
        """Click element theo resource ID"""
        try:
            if self.is_connected():
                element = self.d(resourceId=resource_id)
                if element.wait(timeout=timeout):
                    element.click()
                    return True
        except Exception as e:
            print(f"‚ùå L·ªói click by resource ID: {e}")
        return False
    
    def element_exists(self, **kwargs) -> bool:
        """Ki·ªÉm tra element c√≥ t·ªìn t·∫°i kh√¥ng"""
        try:
            if self.is_connected():
                return self.d(**kwargs).exists
        except:
            pass
        return False

class DeviceWorker(QThread):
    """Worker thread ƒë·ªÉ ch·∫°y flow tr√™n device"""
    
    # Signals
    log_message = pyqtSignal(str, str)  # message, level
    flow_finished = pyqtSignal(str, bool)  # device_id, success
    
    def __init__(self, device_id: str, flow_function=None):
        super().__init__()
        self.device_id = device_id
        self.device = None
        self.flow_function = flow_function
        self.stop_requested = False
        
    def log(self, message: str, level: str = "INFO"):
        """Emit log message"""
        self.log_message.emit(f"[{self.device_id}] {message}", level)
    
    def run(self):
        """Main thread execution"""
        try:
            # Initialize device
            # ƒê·∫£m b·∫£o device_id c√≥ format IP:5555 cho network devices
            device_id = self.device_id
            if ':' not in device_id and '.' in device_id:  # IP address without port
                device_id = f"{device_id}:5555"
            
            self.device = Device(device_id)
            if not self.device.connect():
                self.log("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi device", "ERROR")
                self.flow_finished.emit(self.device_id, False)
                return
            
            self.log("‚úÖ ƒê√£ k·∫øt n·ªëi device", "SUCCESS")
            
            # Run flow if provided
            if self.flow_function and not self.stop_requested:
                try:
                    result = self.flow_function(self.device)
                    if result:
                        self.log("‚úÖ Flow ho√†n th√†nh th√†nh c√¥ng", "SUCCESS")
                        self.flow_finished.emit(self.device_id, True)
                    else:
                        self.log("‚ö†Ô∏è Flow ho√†n th√†nh v·ªõi l·ªói", "WARNING")
                        self.flow_finished.emit(self.device_id, False)
                except Exception as e:
                    self.log(f"‚ùå Flow crashed: {e}", "ERROR")
                    self.flow_finished.emit(self.device_id, False)
            
        except Exception as e:
            self.log(f"‚ùå Worker error: {e}", "ERROR")
            self.flow_finished.emit(self.device_id, False)
        finally:
            if self.device:
                self.device.disconnect()
    
    def stop(self):
        """Request stop"""
        self.stop_requested = True
        self.quit()
        self.wait()

class DeviceManager(QObject):
    """Device Manager v·ªõi GUI integration"""
    
    # Signals
    devices_updated = pyqtSignal(list)  # List of device IDs
    device_connected = pyqtSignal(str)  # device_id
    device_disconnected = pyqtSignal(str)  # device_id
    log_message = pyqtSignal(str, str)  # message, level
    
    def __init__(self):
        super().__init__()
        self.connected_devices = {}  # device_id -> Device object
        self.workers = {}  # device_id -> DeviceWorker
        self.phone_mapping = {}  # IP -> phone number (cached from DataManager)
        
        # Load phone mapping t·ª´ DataManager
        self.load_phone_mapping()
    
    def get_available_devices(self) -> List[str]:
        """L·∫•y danh s√°ch devices c√≥ s·∫µn t·ª´ ADB"""
        try:
            result = subprocess.run(["adb", "devices"], capture_output=True, text=True, timeout=10)
            devices_output = result.stdout
            
            # Parse danh s√°ch devices
            lines = devices_output.strip().split('\n')[1:]  # B·ªè d√≤ng header
            available_devices = []
            for line in lines:
                if line.strip() and '\t' in line:
                    device_id = line.split('\t')[0]
                    status = line.split('\t')[1]
                    if status == 'device':  # Ch·ªâ l·∫•y devices ƒë√£ s·∫µn s√†ng
                        available_devices.append(device_id)
            
            self.devices_updated.emit(available_devices)
            return available_devices
        except Exception as e:
            self.log_message.emit(f"‚ùå L·ªói ki·ªÉm tra ADB devices: {e}", "ERROR")
            return []
    
    def connect_device(self, device_id: str) -> bool:
        """K·∫øt n·ªëi ƒë·∫øn device"""
        if device_id in self.connected_devices:
            return True
        
        # ƒê·∫£m b·∫£o device_id c√≥ format IP:5555 cho network devices
        if ':' not in device_id and '.' in device_id:  # IP address without port
            device_id = f"{device_id}:5555"
        
        device = Device(device_id)
        if device.connect():
            self.connected_devices[device_id] = device
            self.device_connected.emit(device_id)
            self.log_message.emit(f"‚úÖ ƒê√£ k·∫øt n·ªëi device: {device_id}", "SUCCESS")
            return True
        else:
            self.log_message.emit(f"‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi device: {device_id}", "ERROR")
            return False
    
    def disconnect_device(self, device_id: str):
        """Ng·∫Øt k·∫øt n·ªëi device"""
        if device_id in self.connected_devices:
            self.connected_devices[device_id].disconnect()
            del self.connected_devices[device_id]
            self.device_disconnected.emit(device_id)
            self.log_message.emit(f"üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi device: {device_id}", "INFO")
    
    def get_device(self, device_id: str) -> Optional[Device]:
        """L·∫•y device object"""
        return self.connected_devices.get(device_id)
    
    def get_devices(self):
        """Get list of connected devices"""
        try:
            result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)
            lines = result.stdout.strip().split('\n')[1:]  # Skip header
            devices = []
            for line in lines:
                if line.strip() and '\t' in line:
                    device_id, status = line.split('\t')
                    devices.append({
                        'id': device_id,
                        'status': status,
                        'name': f'Device {device_id[:8]}'
                    })
            return devices
        except Exception as e:
            print(f"Error getting devices: {e}")
            return []
    
    def get_connected_devices(self):
        """L·∫•y danh s√°ch devices ƒë√£ k·∫øt n·ªëi - alias for get_devices for compatibility"""
        return self.get_devices()
    
    def load_phone_mapping(self):
        """Load phone mapping t·ª´ DataManager"""
        try:
            self.phone_mapping = data_manager.get_phone_mapping()
            self.log_message.emit(f"üìû ƒê√£ load {len(self.phone_mapping)} phone mappings t·ª´ master config", "INFO")
        except Exception as e:
            self.log_message.emit(f"‚ö†Ô∏è L·ªói load phone mapping: {e}", "WARNING")
    
    def save_phone_mapping(self):
        """L∆∞u phone mapping v√†o DataManager"""
        try:
            # DataManager t·ª± ƒë·ªông l∆∞u khi set phone mapping
            self.log_message.emit(f"üíæ Phone mapping ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o master config", "SUCCESS")
            return True
        except Exception as e:
            self.log_message.emit(f"‚ùå L·ªói l∆∞u phone mapping: {e}", "ERROR")
            return False
    
    def set_phone_mapping(self, ip: str, phone: str):
        """Set phone mapping cho IP"""
        self.phone_mapping[ip] = phone
        # L∆∞u v√†o DataManager
        data_manager.set_phone_mapping(ip, phone)
    
    def get_phone_mapping(self, ip: str) -> str:
        """L·∫•y phone number cho IP"""
        # Refresh t·ª´ DataManager ƒë·ªÉ ƒë·∫£m b·∫£o data m·ªõi nh·∫•t
        phone = data_manager.get_phone_by_ip(ip)
        return phone if phone else ""
    
    def run_flow_on_device(self, device_id: str, flow_function):
        """Ch·∫°y flow tr√™n device trong thread ri√™ng"""
        if device_id in self.workers:
            self.workers[device_id].stop()
        
        worker = DeviceWorker(device_id, flow_function)
        worker.log_message.connect(self.log_message)
        worker.flow_finished.connect(self._on_flow_finished)
        
        self.workers[device_id] = worker
        worker.start()
    
    def _on_flow_finished(self, device_id: str, success: bool):
        """Callback khi flow ho√†n th√†nh"""
        if device_id in self.workers:
            del self.workers[device_id]
        
        status = "th√†nh c√¥ng" if success else "th·∫•t b·∫°i"
        self.log_message.emit(f"üèÅ Flow tr√™n {device_id} ho√†n th√†nh {status}", "INFO")
    
    def stop_all_flows(self):
        """D·ª´ng t·∫•t c·∫£ flows ƒëang ch·∫°y"""
        for worker in self.workers.values():
            worker.stop()
        self.workers.clear()
        self.log_message.emit("üõë ƒê√£ d·ª´ng t·∫•t c·∫£ flows", "INFO")
    
    def disconnect_all_devices(self):
        """Ng·∫Øt k·∫øt n·ªëi t·∫•t c·∫£ devices"""
        for device_id in list(self.connected_devices.keys()):
            self.disconnect_device(device_id)
        self.log_message.emit("üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi t·∫•t c·∫£ devices", "INFO")
    
    def cleanup(self):
        """Cleanup resources"""
        self.stop_all_flows()
        for device in self.connected_devices.values():
            device.disconnect()
        self.connected_devices.clear()