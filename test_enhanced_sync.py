#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test script cho Enhanced Barrier Synchronization
Ki·ªÉm tra c∆° ch·∫ø ƒë·ªìng b·ªô gi·ªØa nhi·ªÅu m√°y ƒë·ªÉ ƒë·∫£m b·∫£o t·∫•t c·∫£ m·ªü Zalo c√πng l√∫c
"""

import os
import sys
import time
import json
import threading
import subprocess
from datetime import datetime

# Add current directory to path ƒë·ªÉ import core1
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from core1 import (
        wait_for_group_barrier, 
        signal_ready_at_barrier, 
        cleanup_barrier_file,
        get_barrier_file_path,
        determine_group_and_role
    )
except ImportError as e:
    print(f"‚ùå Kh√¥ng th·ªÉ import t·ª´ core1: {e}")
    print("üí° ƒê·∫£m b·∫£o file core1.py t·ªìn t·∫°i trong c√πng th∆∞ m·ª•c")
    sys.exit(1)

class SyncTester:
    """Class ƒë·ªÉ test c∆° ch·∫ø ƒë·ªìng b·ªô Enhanced Barrier"""
    
    def __init__(self):
        self.test_results = []
        self.start_time = time.time()
        
    def log_test(self, test_name, status, details="", duration=0):
        """Ghi log k·∫øt qu·∫£ test"""
        result = {
            'test_name': test_name,
            'status': status,
            'details': details,
            'duration': duration,
            'timestamp': datetime.now().strftime('%H:%M:%S')
        }
        self.test_results.append(result)
        
        status_icon = "‚úÖ" if status == "PASS" else "‚ùå" if status == "FAIL" else "‚ö†Ô∏è"
        print(f"{status_icon} [{result['timestamp']}] {test_name}: {status}")
        if details:
            print(f"   üìù {details}")
        if duration > 0:
            print(f"   ‚è±Ô∏è Duration: {duration:.2f}s")
        print()
    
    def simulate_device(self, device_ip, group_id, device_count, barrier_timeout=60):
        """M√¥ ph·ªèng m·ªôt device tham gia barrier synchronization"""
        start_time = time.time()
        
        try:
            print(f"üöÄ Device {device_ip} - B·∫Øt ƒë·∫ßu simulation cho nh√≥m {group_id}")
            
            # Signal ready
            signal_success = signal_ready_at_barrier(group_id, device_ip)
            if not signal_success:
                return False, f"Signal failed for {device_ip}"
            
            # Wait for barrier
            barrier_success = wait_for_group_barrier(group_id, device_count, timeout=barrier_timeout)
            
            duration = time.time() - start_time
            
            if barrier_success:
                return True, f"Device {device_ip} synchronized successfully in {duration:.2f}s"
            else:
                return False, f"Device {device_ip} timeout after {duration:.2f}s"
                
        except Exception as e:
            duration = time.time() - start_time
            return False, f"Device {device_ip} error after {duration:.2f}s: {e}"
    
    def test_basic_barrier_sync(self):
        """Test c∆° b·∫£n: 2 devices ƒë·ªìng b·ªô"""
        test_start = time.time()
        group_id = "test_basic"
        device_count = 2
        devices = ["192.168.1.100", "192.168.1.101"]
        
        print(f"üß™ Test Basic Barrier Sync - Nh√≥m {group_id}")
        print(f"üìã Devices: {devices}")
        
        # Cleanup tr∆∞·ªõc khi test
        cleanup_barrier_file(group_id)
        
        # T·∫°o threads cho m·ªói device
        threads = []
        results = {}
        
        def device_thread(device_ip, delay=0):
            if delay > 0:
                time.sleep(delay)
            success, details = self.simulate_device(device_ip, group_id, device_count, 30)
            results[device_ip] = (success, details)
        
        # Start t·∫•t c·∫£ threads v·ªõi delay nh·ªè
        for i, device_ip in enumerate(devices):
            delay = i * 0.1  # Delay 0.1s gi·ªØa c√°c devices
            thread = threading.Thread(target=device_thread, args=(device_ip, delay))
            threads.append(thread)
            thread.start()
        
        # Wait cho t·∫•t c·∫£ threads
        for thread in threads:
            thread.join()
        
        # Ki·ªÉm tra k·∫øt qu·∫£
        duration = time.time() - test_start
        all_success = all(result[0] for result in results.values())
        
        if all_success:
            self.log_test("Basic Barrier Sync", "PASS", 
                         f"T·∫•t c·∫£ {device_count} devices ƒë·ªìng b·ªô th√†nh c√¥ng", duration)
        else:
            failed_devices = [ip for ip, (success, _) in results.items() if not success]
            self.log_test("Basic Barrier Sync", "FAIL", 
                         f"Devices failed: {failed_devices}", duration)
        
        # Cleanup
        cleanup_barrier_file(group_id)
        return all_success
    
    def test_timeout_scenario(self):
        """Test scenario timeout: ch·ªâ 1 device signal ready"""
        test_start = time.time()
        group_id = "test_timeout"
        device_count = 2
        single_device = "192.168.1.200"
        
        print(f"üß™ Test Timeout Scenario - Nh√≥m {group_id}")
        print(f"üìã Ch·ªâ 1/{device_count} devices s·∫Ω signal ready")
        
        # Cleanup tr∆∞·ªõc khi test
        cleanup_barrier_file(group_id)
        
        # Ch·ªâ 1 device signal ready, timeout ng·∫Øn ƒë·ªÉ test nhanh
        success, details = self.simulate_device(single_device, group_id, device_count, 10)
        
        duration = time.time() - test_start
        
        # Trong tr∆∞·ªùng h·ª£p n√†y, expect timeout (success = False)
        if not success and "timeout" in details.lower():
            self.log_test("Timeout Scenario", "PASS", 
                         f"Timeout ƒë√∫ng nh∆∞ mong ƒë·ª£i: {details}", duration)
            result = True
        else:
            self.log_test("Timeout Scenario", "FAIL", 
                         f"Kh√¥ng timeout nh∆∞ mong ƒë·ª£i: {details}", duration)
            result = False
        
        # Cleanup
        cleanup_barrier_file(group_id)
        return result
    
    def test_multiple_groups(self):
        """Test nhi·ªÅu nh√≥m ƒë·ªìng th·ªùi"""
        test_start = time.time()
        
        print(f"üß™ Test Multiple Groups Simultaneously")
        
        groups = {
            "group_A": ["192.168.1.10", "192.168.1.11"],
            "group_B": ["192.168.1.20", "192.168.1.21"]
        }
        
        # Cleanup t·∫•t c·∫£ groups
        for group_id in groups.keys():
            cleanup_barrier_file(group_id)
        
        threads = []
        results = {}
        
        def group_thread(group_id, devices):
            group_results = {}
            group_threads = []
            
            def device_thread(device_ip, delay=0):
                if delay > 0:
                    time.sleep(delay)
                success, details = self.simulate_device(device_ip, group_id, len(devices), 30)
                group_results[device_ip] = (success, details)
            
            # Start devices trong group v·ªõi delay ng·∫´u nhi√™n nh·ªè
            for i, device_ip in enumerate(devices):
                delay = i * 0.1  # Delay 0.1s gi·ªØa c√°c devices
                thread = threading.Thread(target=device_thread, args=(device_ip, delay))
                group_threads.append(thread)
                thread.start()
            
            # Wait cho t·∫•t c·∫£ devices trong group
            for thread in group_threads:
                thread.join()
            
            results[group_id] = group_results
        
        # Start t·∫•t c·∫£ groups
        for group_id, devices in groups.items():
            thread = threading.Thread(target=group_thread, args=(group_id, devices))
            threads.append(thread)
            thread.start()
        
        # Wait cho t·∫•t c·∫£ groups
        for thread in threads:
            thread.join()
        
        # Ki·ªÉm tra k·∫øt qu·∫£
        duration = time.time() - test_start
        all_groups_success = True
        
        for group_id, group_results in results.items():
            group_success = all(result[0] for result in group_results.values())
            if not group_success:
                all_groups_success = False
                failed_devices = [ip for ip, (success, _) in group_results.items() if not success]
                print(f"‚ùå Group {group_id} failed: {failed_devices}")
            else:
                print(f"‚úÖ Group {group_id} success: {list(group_results.keys())}")
        
        if all_groups_success:
            self.log_test("Multiple Groups", "PASS", 
                         f"T·∫•t c·∫£ {len(groups)} groups ƒë·ªìng b·ªô th√†nh c√¥ng", duration)
        else:
            self.log_test("Multiple Groups", "FAIL", 
                         "M·ªôt s·ªë groups failed", duration)
        
        # Cleanup
        for group_id in groups.keys():
            cleanup_barrier_file(group_id)
        
        return all_groups_success
    
    def test_determine_group_and_role(self):
        """Test h√†m determine_group_and_role"""
        test_start = time.time()
        
        print(f"üß™ Test Group and Role Determination")
        
        test_cases = [
            {
                'devices': ['192.168.1.100', '192.168.1.101'],
                'expected_groups': 1
            },
            {
                'devices': ['192.168.1.100', '192.168.1.101', '192.168.1.102', '192.168.1.103'],
                'expected_groups': 2
            },
            {
                'devices': ['10.0.0.1', '10.0.0.2', '10.0.0.3'],
                'expected_groups': 2  # 3 devices = 2 groups (2+1)
            }
        ]
        
        all_passed = True
        
        for i, case in enumerate(test_cases):
            devices = case['devices']
            expected_groups = case['expected_groups']
            
            # Test v·ªõi device ƒë·∫ßu ti√™n
            test_ip = devices[0]
            group_id, role = determine_group_and_role(test_ip, devices)
            
            # Ki·ªÉm tra t·∫•t c·∫£ devices ƒë·ªÉ ƒë·∫øm s·ªë groups
            groups_found = set()
            for device in devices:
                gid, _ = determine_group_and_role(device, devices)
                groups_found.add(gid)
            
            actual_groups = len(groups_found)
            
            if actual_groups == expected_groups:
                print(f"‚úÖ Test case {i+1}: {actual_groups} groups (expected {expected_groups})")
            else:
                print(f"‚ùå Test case {i+1}: {actual_groups} groups (expected {expected_groups})")
                all_passed = False
        
        duration = time.time() - test_start
        
        if all_passed:
            self.log_test("Group and Role Determination", "PASS", 
                         "T·∫•t c·∫£ test cases passed", duration)
        else:
            self.log_test("Group and Role Determination", "FAIL", 
                         "M·ªôt s·ªë test cases failed", duration)
        
        return all_passed
    
    def run_all_tests(self):
        """Ch·∫°y t·∫•t c·∫£ tests"""
        print("üöÄ B·∫Øt ƒë·∫ßu Enhanced Sync Testing")
        print("=" * 50)
        
        tests = [
            self.test_determine_group_and_role,
            self.test_basic_barrier_sync,
            self.test_timeout_scenario,
            self.test_multiple_groups
        ]
        
        passed = 0
        total = len(tests)
        
        for test_func in tests:
            try:
                if test_func():
                    passed += 1
            except Exception as e:
                self.log_test(test_func.__name__, "ERROR", f"Exception: {e}")
        
        print("=" * 50)
        print(f"üìä Test Summary: {passed}/{total} tests passed")
        
        total_duration = time.time() - self.start_time
        print(f"‚è±Ô∏è Total duration: {total_duration:.2f}s")
        
        if passed == total:
            print("üéâ T·∫•t c·∫£ tests PASSED! Enhanced Sync ho·∫°t ƒë·ªông t·ªët.")
            return True
        else:
            print(f"‚ö†Ô∏è {total - passed} tests FAILED. C·∫ßn ki·ªÉm tra l·∫°i.")
            return False
    
    def print_detailed_results(self):
        """In chi ti·∫øt k·∫øt qu·∫£ tests"""
        print("\nüìã Detailed Test Results:")
        print("-" * 60)
        
        for result in self.test_results:
            status_icon = "‚úÖ" if result['status'] == "PASS" else "‚ùå" if result['status'] == "FAIL" else "‚ö†Ô∏è"
            print(f"{status_icon} [{result['timestamp']}] {result['test_name']}")
            print(f"   Status: {result['status']}")
            if result['details']:
                print(f"   Details: {result['details']}")
            if result['duration'] > 0:
                print(f"   Duration: {result['duration']:.2f}s")
            print()

def main():
    """Main function"""
    print("üîß Enhanced Barrier Synchronization Test Suite")
    print(f"üìÖ Start time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    tester = SyncTester()
    
    try:
        success = tester.run_all_tests()
        tester.print_detailed_results()
        
        if success:
            print("\nüéØ K·∫øt lu·∫≠n: Enhanced Sync mechanism ho·∫°t ƒë·ªông t·ªët!")
            print("üí° T·∫•t c·∫£ m√°y trong c√πng nh√≥m s·∫Ω m·ªü Zalo ƒë·ªìng th·ªùi.")
            return 0
        else:
            print("\n‚ö†Ô∏è K·∫øt lu·∫≠n: C·∫ßn c·∫£i ti·∫øn th√™m Enhanced Sync mechanism.")
            return 1
            
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Test b·ªã d·ª´ng b·ªüi user")
        return 1
    except Exception as e:
        print(f"\n‚ùå Test error: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())